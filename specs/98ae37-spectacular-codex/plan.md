---
runId: 98ae37
feature: spectacular-codex
created: 2025-01-13
status: ready
---

# Feature: Spectacular-Codex MCP Server - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/98ae37-spectacular-codex/spec.md
> **Created:** 2025-01-13

## Execution Summary

- **Total Tasks**: 18
- **Total Phases**: 5
- **Sequential Time**: 57h
- **Parallel Time**: 41h
- **Time Savings**: 16h (28% faster)

**Parallel Opportunities:**

- Phase 1: 4 tasks (13h → 4h, 9h saved)
- Phase 2: 4 tasks (17h → 6h, 11h saved)
- Phase 3: 3 tasks (10h → 5h, 5h saved)
- Phase 4: 4 tasks (17h → 5h, 12h saved)
- Phase 5: 3 tasks (10h → 4h, 6h saved)

---

## Phase 1: Foundation

**Strategy**: parallel
**Reason**: Independent foundation modules - project config, types, git utils, parsing - can be built concurrently

### Task 1-1: Project Setup & Dependencies

**Files**:
- package.json
- tsconfig.json
- .github/workflows/publish.yml

**Complexity**: M (3h)

**Dependencies**: None

**Description**:
Configure project for MCP server development. Update package.json with real dependencies (@openai/codex, @modelcontextprotocol/sdk, execa), configure strict TypeScript, set up npm publishing workflow.

**Implementation Steps**:

1. Update package.json:
   - Change name from "ts-fast-project" to "spectacular-codex"
   - Update description to "MCP server for Spectacular parallel orchestration in Codex CLI"
   - Add dependencies: @openai/codex, @modelcontextprotocol/sdk, execa
   - Set bin to dist/index.js
   - Update scripts (keep existing test/lint/build)

2. Verify tsconfig.json has strict mode:
   - strict: true
   - noUncheckedIndexedAccess: true
   - noImplicitOverride: true
   - exactOptionalPropertyTypes: true

3. Create GitHub workflow for npm publishing:
   - .github/workflows/publish.yml
   - Trigger on version tags (v*)
   - Build → test → publish to npm

**Acceptance Criteria**:

- [ ] package.json has correct dependencies (@openai/codex, @modelcontextprotocol/sdk, execa)
- [ ] tsconfig.json has all strict flags enabled
- [ ] pnpm install runs without errors
- [ ] .github/workflows/publish.yml exists and triggers on version tags

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

See architecture.md for layer boundaries and patterns.md for required patterns.

**Quality Gates**:

```bash
pnpm install
pnpm check-types
pnpm biome check --write .
```

---

### Task 1-2: TypeScript Core Types

**Files**:
- src/types.ts

**Complexity**: S (2h)

**Dependencies**: None

**Description**:
Define all TypeScript interfaces for the MCP server: ExecutionJob, Task, Phase, Plan, CodexThreadResult, StackingBackend. Use strict union types for status enums, no `any` types.

**Implementation Steps**:

1. Create src/types.ts
2. Define core interfaces:
   - ExecutionJob: runId, status (union type), phase, tasks, startedAt, error?
   - Task: id, name, description, files, complexity, estimatedHours, acceptanceCriteria, steps
   - Phase: id, name, strategy ('sequential' | 'parallel'), tasks, dependencies?
   - Plan: runId, featureSlug, phases, baseRef
   - CodexThreadResult: success, task, branch?, error?
   - StackingBackend: interface with stackBranches(), detectBackend() methods

3. Use strict union types (not string):
   - Status: 'running' | 'completed' | 'failed'
   - Strategy: 'sequential' | 'parallel'
   - Complexity: 'S' | 'M' | 'L' | 'XL'

**Acceptance Criteria**:

- [ ] All interfaces defined with strict types (no `any`)
- [ ] Status and strategy use union types (not string)
- [ ] Optional fields marked with `?` (error?, dependencies?)
- [ ] pnpm check-types passes

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

TypeScript strict mode is MANDATORY per tech-stack.md. Use union types for enums.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm check-types
pnpm test src/types.test.ts
```

---

### Task 1-3: Git Utils Module

**Files**:
- src/utils/git.ts
- src/utils/git.test.ts

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Implement pure utility functions for git operations: createWorktree(), cleanupWorktree(), findBranch(), branchHasCommits(). Use execa with array args (no shell injection). All functions must be stateless.

**Implementation Steps**:

1. Create src/utils/git.ts
2. Implement pure functions (stateless, no side effects except IO):
   - createWorktree(path, baseRef): git worktree add with --detach
   - cleanupWorktree(path): git worktree remove
   - findBranch(pattern): git branch --list with grep
   - branchHasCommits(branch): git log --oneline -1 <branch>
   - listWorktrees(): git worktree list

3. Use execa with array args (mandatory per patterns.md):
   ```typescript
   await execa('git', ['worktree', 'add', path, '--detach', baseRef]);
   ```

4. Write tests in src/utils/git.test.ts:
   - Test in temp git repos
   - Verify worktree creation/cleanup
   - Verify branch detection

**Acceptance Criteria**:

- [ ] All functions use execa with array args (no shell strings)
- [ ] Functions are pure (no internal state)
- [ ] Tests pass for worktree operations
- [ ] findBranch() correctly matches branch patterns
- [ ] branchHasCommits() returns false for empty branches

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Pure utility functions are REQUIRED per patterns.md. Use execa for all git commands.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/utils/git.test.ts
pnpm biome check --write src/utils/git.ts
pnpm check-types
```

---

### Task 1-4: Plan Parser & Project Config Utils

**Files**:
- src/utils/plan-parser.ts
- src/utils/plan-parser.test.ts
- src/utils/project-config.ts
- src/utils/project-config.test.ts
- src/utils/branch-tracker.ts
- src/utils/branch-tracker.test.ts

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Implement plan.md parsing (extract runId, phases, tasks from markdown), project config detection (AGENTS.md, package.json scripts, git hooks), and branch tracking (check existence, verify commits). All pure functions.

**Implementation Steps**:

1. Create src/utils/plan-parser.ts:
   - parsePlan(planPath): Read plan.md, extract frontmatter (runId, feature), parse phases/tasks
   - extractRunId(planPath): Extract runId from path or frontmatter
   - validatePlan(plan): Check for required fields

2. Create src/utils/project-config.ts:
   - detectInstallCommand(): Check AGENTS.md, fallback to package.json
   - detectQualityChecks(): Check AGENTS.md for test/lint/build commands
   - detectGitHooks(): Check for lefthook.yml, .husky/

3. Create src/utils/branch-tracker.ts:
   - checkExistingWork(phase, runId): Return completed vs pending tasks
   - isTaskComplete(task, runId): Check if branch exists with commits

4. Write tests for all modules (TDD)

**Acceptance Criteria**:

- [ ] parsePlan() extracts runId, phases, tasks from markdown
- [ ] detectQualityChecks() finds commands in AGENTS.md or package.json
- [ ] checkExistingWork() correctly identifies completed tasks via git branches
- [ ] All functions are pure (no state)
- [ ] Tests pass for all utilities

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Pure utility functions per patterns.md. Git-based state per schema-rules.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/utils/plan-parser.test.ts
pnpm test src/utils/project-config.test.ts
pnpm test src/utils/branch-tracker.test.ts
pnpm check-types
```

---

## Phase 2: Parallel Execution MVP

**Strategy**: parallel
**Reason**: Prompt templates, orchestrator, stacking backend, handler can be developed concurrently with types from Phase 1

### Task 2-1: Task Executor Prompt Template

**Files**:
- src/prompts/task-executor.ts
- src/prompts/task-executor.test.ts

**Complexity**: M (3h)

**Dependencies**: [task-1-2]

**Description**:
Generate prompts for task execution with embedded skill instructions (TDD, phase-task-verification). Reference skills by name but include full instructions inline. Include quality checks, git operations, branch creation.

**Implementation Steps**:

1. Create src/prompts/task-executor.ts
2. Implement generateTaskPrompt(task, plan, qualityChecks):
   - Embed test-driven-development skill instructions
   - Embed phase-task-verification skill instructions
   - Include task context (id, name, description, files)
   - Include acceptance criteria as checklist
   - Include implementation steps
   - Include quality check commands
   - Include git operations (branch create, detach HEAD)

3. Pattern from patterns.md:
   ```typescript
   return `
   You are implementing Task ${task.id}: ${task.name}

   ## Your Process (from test-driven-development and phase-task-verification skills)

   ### 1. Navigate to Worktree
   cd .worktrees/${plan.runId}-task-${task.id}

   ### 2. Implement Task (TDD)
   - Write test first
   - Watch it fail
   - Write minimal code to pass
   - Watch it pass

   ### 3. Create Branch
   gs branch create ${plan.runId}-task-${task.id}-{name} -m "..."

   ### 4. Detach HEAD
   git switch --detach
   `;
   ```

4. Write unit tests: verify prompt includes all required sections

**Acceptance Criteria**:

- [ ] Prompt embeds TDD skill instructions inline
- [ ] Prompt embeds phase-task-verification skill instructions
- [ ] Prompt includes quality check commands
- [ ] Prompt includes git branch creation steps
- [ ] Tests verify all sections present

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Skills must be embedded in prompts per patterns.md (Codex threads can't read skill files).

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/prompts/task-executor.test.ts
pnpm check-types
```

---

### Task 2-2: Parallel Phase Orchestrator

**Files**:
- src/orchestrator/parallel-phase.ts
- src/orchestrator/parallel-phase.test.ts

**Complexity**: L (6h)

**Dependencies**: [task-1-2, task-1-3, task-2-1]

**Description**:
Implement parallel phase execution: create worktrees, spawn N Codex threads via Promise.all(), stack branches, cleanup. Handle individual task failures gracefully (wait for all, don't stop on first failure).

**Implementation Steps**:

1. Create src/orchestrator/parallel-phase.ts
2. Implement executeParallelPhase(phase, plan, job):
   - Check existing work (resume logic)
   - Create worktrees for pending tasks
   - Spawn threads in parallel:
     ```typescript
     const threadPromises = tasks.map(async task => {
       try {
         const codex = new Codex({ workingDirectory: `.worktrees/${runId}-task-${task.id}` });
         const thread = codex.startThread();
         const prompt = generateTaskPrompt(task, plan);
         const result = await thread.run(prompt);
         return { success: true, task: task.id, branch: extractBranchName(result) };
       } catch (error) {
         return { success: false, task: task.id, error: String(error) };
       }
     });
     const results = await Promise.all(threadPromises);
     ```
   - Stack branches (delegate to stacking backend)
   - Cleanup worktrees

3. Write integration tests with mocked Codex SDK:
   - Verify Promise.all() spawns N threads
   - Verify individual failures don't stop other threads
   - Verify worktree cleanup after stacking

**Acceptance Criteria**:

- [ ] Spawns N threads via Promise.all() (true parallelism)
- [ ] Individual task failures tracked without stopping other threads
- [ ] Worktrees created for pending tasks only (resume logic)
- [ ] Branches stacked after all threads complete
- [ ] Worktrees cleaned up after stacking
- [ ] Integration tests pass with mocked Codex SDK

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Parallel execution pattern (Promise.all) is MANDATORY per patterns.md. Async job pattern required.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/orchestrator/parallel-phase.test.ts
pnpm check-types
```

---

### Task 2-3: Stacking Backend Abstraction

**Files**:
- src/utils/stacking/types.ts
- src/utils/stacking/git-spice.ts
- src/utils/stacking/git-spice.test.ts
- src/utils/stacking/index.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-2, task-1-3]

**Description**:
Create pluggable stacking backend abstraction. v1 implements git-spice only. Backend detection via env var or auto-detect. Clear error if backend unavailable.

**Implementation Steps**:

1. Create src/utils/stacking/types.ts:
   - StackingBackend interface: stackBranches(branches, baseRef), detectBackend()

2. Create src/utils/stacking/git-spice.ts:
   - GitSpiceBackend class implementing StackingBackend
   - stackBranches(): Use `gs upstack onto` for each branch
   - detectBackend(): Check if `gs` command exists

3. Create src/utils/stacking/index.ts:
   - getStackingBackend(): Factory function
   - Check STACKING_BACKEND env var
   - Auto-detect if not set (git-spice only in v1)
   - Throw clear error if backend unavailable

4. Write tests:
   - Verify git-spice stacking commands
   - Verify error if backend not found

**Acceptance Criteria**:

- [ ] StackingBackend interface defined
- [ ] GitSpiceBackend implements interface
- [ ] getStackingBackend() returns git-spice backend in v1
- [ ] Clear error thrown if git-spice not installed
- [ ] Tests verify stacking operations

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Selective abstraction per architecture.md. Pure utility functions per patterns.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/utils/stacking/
pnpm check-types
```

---

### Task 2-4: Execute Handler

**Files**:
- src/handlers/execute.ts
- src/handlers/execute.test.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-2, task-1-4, task-2-2]

**Description**:
Implement MCP tool handler for `spectacular_execute`. Parse plan_path arg, create ExecutionJob, delegate to orchestrators, return run_id immediately (async job pattern). Background execution continues.

**Implementation Steps**:

1. Create src/handlers/execute.ts
2. Implement handleExecute(args):
   - Parse plan_path argument
   - Extract runId via extractRunId()
   - Parse plan via parsePlan()
   - Create ExecutionJob tracker
   - Execute phases in background (non-blocking):
     ```typescript
     const job = { runId, status: 'running', ... };
     this.jobs.set(runId, job);

     this.executePhases(plan, job).catch(err => {
       job.status = 'failed';
       job.error = String(err);
     });

     return { run_id: runId, status: 'started' };
     ```

3. Implement executePhases(plan, job):
   - For each phase, delegate to parallel or sequential orchestrator
   - Update job status as phases complete

4. Write integration tests:
   - Verify handler returns immediately
   - Verify background execution updates job status
   - Verify plan parsing errors return error response

**Acceptance Criteria**:

- [ ] Handler returns immediately with run_id (async job pattern)
- [ ] ExecutionJob created and tracked in-memory
- [ ] Background execution updates job status
- [ ] Plan parsing errors handled gracefully
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Async job pattern is MANDATORY per patterns.md. Handler must return immediately.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/handlers/execute.test.ts
pnpm check-types
```

---

## Phase 3: Code Review

**Strategy**: parallel
**Reason**: Review/fixer prompts, code review orchestrator, status handler are independent modules

### Task 3-1: Review & Fixer Prompt Templates

**Files**:
- src/prompts/code-reviewer.ts
- src/prompts/code-reviewer.test.ts
- src/prompts/fixer.ts
- src/prompts/fixer.test.ts

**Complexity**: M (3h)

**Dependencies**: [task-1-2]

**Description**:
Generate prompts for code review (checklist, binary verdict format) and fixer (fix strategy, scope creep detection). Embed skill instructions inline.

**Implementation Steps**:

1. Create src/prompts/code-reviewer.ts:
   - generateReviewPrompt(phase, plan):
     - Include phase context (tasks, branches)
     - Embed review checklist (constitution compliance, tests pass, etc.)
     - Embed binary verdict format: "VERDICT: APPROVED" or "VERDICT: REJECTED"
     - Include rejection reasons format

2. Create src/prompts/fixer.ts:
   - generateFixerPrompt(reviewResult, plan):
     - Parse rejection reasons from review
     - Embed fix strategy instructions
     - Embed scope creep detection
     - Include quality check re-run

3. Write unit tests:
   - Verify prompts include required sections
   - Verify verdict format instructions

**Acceptance Criteria**:

- [ ] Review prompt includes binary verdict format
- [ ] Review prompt embeds checklist instructions
- [ ] Fixer prompt includes rejection reasons
- [ ] Fixer prompt includes scope creep detection
- [ ] Tests verify all sections present

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Skills embedded in prompts per patterns.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/prompts/code-reviewer.test.ts
pnpm test src/prompts/fixer.test.ts
pnpm check-types
```

---

### Task 3-2: Code Review Orchestrator

**Files**:
- src/orchestrator/code-review.ts
- src/orchestrator/code-review.test.ts

**Complexity**: L (5h)

**Dependencies**: [task-1-2, task-3-1]

**Description**:
Implement code review loop: review → fix → re-review in same Codex thread (preserves conversation context). Binary verdict parsing (approved/rejected). Max 3 rejections before escalation.

**Implementation Steps**:

1. Create src/orchestrator/code-review.ts
2. Implement runCodeReview(phase, plan):
   - Spawn single Codex thread (maintain conversation)
   - Loop review → fix (max 3 rejections):
     ```typescript
     const thread = codex.startThread(); // ONE thread
     let rejectionCount = 0;

     while (rejectionCount <= MAX_REJECTIONS) {
       const reviewResult = await thread.run(reviewPrompt);

       if (parseVerdict(reviewResult) === 'approved') {
         return; // Success
       }

       rejectionCount++;
       await thread.run(fixerPrompt); // Same thread
     }
     ```

3. Implement parseVerdict(reviewResult):
   - Parse "VERDICT: APPROVED" or "VERDICT: REJECTED"
   - Extract rejection reasons

4. Write integration tests with mocked Codex SDK:
   - Verify single thread for review loop
   - Verify max rejections enforced
   - Verify verdict parsing

**Acceptance Criteria**:

- [ ] Uses single Codex thread for review → fix loop
- [ ] Max 3 rejections enforced
- [ ] Verdict parsing works (approved/rejected)
- [ ] Conversation context preserved across iterations
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Code review loop pattern per patterns.md (same thread for context).

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/orchestrator/code-review.test.ts
pnpm check-types
```

---

### Task 3-3: Status Handler

**Files**:
- src/handlers/status.ts
- src/handlers/status.test.ts

**Complexity**: S (2h)

**Dependencies**: [task-1-2]

**Description**:
Implement MCP tool handler for `spectacular_status`. Retrieve job from Map, format status response with phase/task progress.

**Implementation Steps**:

1. Create src/handlers/status.ts
2. Implement handleStatus(args):
   - Parse run_id argument
   - Retrieve job from this.jobs.get(runId)
   - If not found, check git branches (resume logic)
   - Format response:
     ```typescript
     return {
       run_id: runId,
       status: job.status,
       phase: job.phase,
       tasks: job.tasks.map(t => ({ id: t.id, status: t.status })),
       error: job.error
     };
     ```

3. Write integration tests:
   - Verify status retrieval
   - Verify error if job not found
   - Verify git branch fallback

**Acceptance Criteria**:

- [ ] Retrieves job status from in-memory Map
- [ ] Falls back to git branches if job not in memory
- [ ] Returns formatted status response
- [ ] Handles missing job gracefully
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Git-based state per schema-rules.md (branches are truth, not in-memory).

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/handlers/status.test.ts
pnpm check-types
```

---

## Phase 4: Sequential & Generators

**Strategy**: parallel
**Reason**: Sequential orchestrator, spec generator, plan generator, MCP server core are independent modules

### Task 4-1: Sequential Phase Orchestrator

**Files**:
- src/orchestrator/sequential-phase.ts
- src/orchestrator/sequential-phase.test.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-2, task-1-3, task-2-1]

**Description**:
Implement sequential phase execution: execute tasks one-by-one in main worktree, natural git-spice stacking (each task builds on previous), quality checks per task, branch per task.

**Implementation Steps**:

1. Create src/orchestrator/sequential-phase.ts
2. Implement executeSequentialPhase(phase, plan, job):
   - Check existing work (resume logic)
   - For each pending task (sequential):
     ```typescript
     for (const task of pendingTasks) {
       const codex = new Codex({ workingDirectory: `.worktrees/${runId}-main` });
       const thread = codex.startThread();
       const prompt = generateTaskPrompt(task, plan);
       const result = await thread.run(prompt);
       // Task creates branch automatically (natural stacking)
     }
     ```

3. Write integration tests with mocked Codex SDK:
   - Verify tasks execute sequentially
   - Verify main worktree used
   - Verify natural stacking (no manual upstack)

**Acceptance Criteria**:

- [ ] Tasks execute one-by-one (sequential)
- [ ] Main worktree used for all tasks
- [ ] Natural git-spice stacking (each task builds on previous)
- [ ] Quality checks run per task
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Sequential orchestration per architecture.md. Git-spice natural stacking.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/orchestrator/sequential-phase.test.ts
pnpm check-types
```

---

### Task 4-2: Spec Generator Prompt & Handler

**Files**:
- src/prompts/spec-generator.ts
- src/prompts/spec-generator.test.ts
- src/handlers/spec.ts
- src/handlers/spec.test.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-2]

**Description**:
Generate prompts for spec generation (embed brainstorming phases: understanding, exploration, design) and implement `spectacular_spec` handler. Create specs/{runId}-{feature-slug}/spec.md.

**Implementation Steps**:

1. Create src/prompts/spec-generator.ts:
   - generateSpecPrompt(featureRequest):
     - Embed brainstorming skill instructions (3 phases)
     - Include understanding phase (ask questions)
     - Include exploration phase (alternatives)
     - Include design phase (finalize spec)
     - Include constitution references (not duplication)

2. Create src/handlers/spec.ts:
   - handleSpec(args):
     - Parse feature_request argument
     - Generate runId (6-char hex)
     - Spawn Codex thread for spec generation
     - Return runId immediately (async pattern)

3. Write tests:
   - Verify prompt includes brainstorming phases
   - Verify handler returns immediately

**Acceptance Criteria**:

- [ ] Spec prompt embeds brainstorming skill instructions
- [ ] Handler returns runId immediately
- [ ] Spec created at specs/{runId}-{feature-slug}/spec.md
- [ ] Tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Skills embedded in prompts per patterns.md. Async job pattern per patterns.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/prompts/spec-generator.test.ts
pnpm test src/handlers/spec.test.ts
pnpm check-types
```

---

### Task 4-3: Plan Generator Prompt & Handler

**Files**:
- src/prompts/plan-generator.ts
- src/prompts/plan-generator.test.ts
- src/handlers/plan.ts
- src/handlers/plan.test.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-2, task-1-4]

**Description**:
Generate prompts for plan decomposition (embed task decomposition skill: extract tasks, analyze dependencies, group into phases) and implement `spectacular_plan` handler. Output specs/{runId}-{feature-slug}/plan.md.

**Implementation Steps**:

1. Create src/prompts/plan-generator.ts:
   - generatePlanPrompt(specPath):
     - Embed task decomposition skill instructions
     - Include task extraction (from spec)
     - Include dependency analysis (file overlaps)
     - Include phase grouping (sequential vs parallel)
     - Include validation (no XL tasks, explicit files)

2. Create src/handlers/plan.ts:
   - handlePlan(args):
     - Parse spec_path argument
     - Extract runId from spec
     - Spawn Codex thread for plan generation
     - Return runId immediately

3. Write tests:
   - Verify prompt includes decomposition instructions
   - Verify handler returns immediately

**Acceptance Criteria**:

- [ ] Plan prompt embeds task decomposition skill instructions
- [ ] Handler returns runId immediately
- [ ] Plan created at specs/{runId}-{feature-slug}/plan.md
- [ ] Tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Skills embedded in prompts per patterns.md. Async job pattern per patterns.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/prompts/plan-generator.test.ts
pnpm test src/handlers/plan.test.ts
pnpm check-types
```

---

### Task 4-4: MCP Server Core

**Files**:
- src/index.ts
- src/index.test.ts

**Complexity**: L (5h)

**Dependencies**: [task-2-4, task-3-3, task-4-2, task-4-3]

**Description**:
Implement MCP server entry point: register tools (execute, status, spec, plan), stdio transport, job state tracking (Map<runId, ExecutionJob>), error handling at layer boundary.

**Implementation Steps**:

1. Create src/index.ts
2. Initialize MCP server:
   - Use @modelcontextprotocol/sdk
   - Configure stdio transport
   - Create job tracker (Map<runId, ExecutionJob>)

3. Register MCP tools:
   - spectacular_execute: handleExecute
   - spectacular_status: handleStatus
   - spectacular_spec: handleSpec
   - spectacular_plan: handlePlan

4. Implement error handling:
   - Catch errors at tool handler boundary
   - Format error responses
   - Log to stderr (stdio transport)

5. Write integration tests:
   - Verify tools registered
   - Verify stdio transport works
   - Verify error handling

**Acceptance Criteria**:

- [ ] MCP server registers 4 tools (execute, status, spec, plan)
- [ ] Stdio transport configured
- [ ] Job state tracked in-memory (Map)
- [ ] Error handling at layer boundary
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

MCP server architecture per architecture.md. Async job pattern per patterns.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/index.test.ts
pnpm check-types
pnpm build
```

---

## Phase 5: Polish & Documentation

**Strategy**: parallel
**Reason**: Resume logic, error handling, documentation are independent polish tasks

### Task 5-1: Resume Logic Implementation

**Files**:
- src/orchestrator/resume.ts
- src/orchestrator/resume.test.ts

**Complexity**: M (4h)

**Dependencies**: [task-1-3, task-1-4, task-2-2, task-4-1]

**Description**:
Implement resume logic: check git branches before execution, skip tasks with branches that have commits, only spawn threads for pending tasks. Git branches = source of truth.

**Implementation Steps**:

1. Create src/orchestrator/resume.ts
2. Implement checkExistingWork(phase, runId):
   - For each task in phase:
     - Check if branch exists (findBranch pattern)
     - Check if branch has commits (branchHasCommits)
     - Mark as completed or pending

3. Integrate with orchestrators:
   - Update executeParallelPhase to use checkExistingWork
   - Update executeSequentialPhase to use checkExistingWork
   - Only create worktrees for pending tasks
   - Only spawn threads for pending tasks

4. Write integration tests:
   - Create fixture branches with commits
   - Verify tasks with branches are skipped
   - Verify only pending tasks executed

**Acceptance Criteria**:

- [ ] checkExistingWork correctly identifies completed tasks via git branches
- [ ] Parallel orchestrator skips completed tasks
- [ ] Sequential orchestrator skips completed tasks
- [ ] Git branches are source of truth (not in-memory state)
- [ ] Integration tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Git-based state per schema-rules.md. Resume logic per architecture.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/orchestrator/resume.test.ts
pnpm check-types
```

---

### Task 5-2: Error Handling & Validation

**Files**:
- src/utils/validation.ts
- src/utils/validation.test.ts

**Complexity**: M (3h)

**Dependencies**: [task-1-2]

**Description**:
Implement input validation (plan paths, runIds, branch names), error handling at layer boundaries, contextual error messages. Prevent shell injection, validate runId format (6-char hex).

**Implementation Steps**:

1. Create src/utils/validation.ts:
   - validatePlanPath(path): Must be under specs/
   - validateRunId(runId): Must be 6-char hex
   - validateBranchName(name): Must start with runId prefix
   - sanitizePath(path): Prevent path traversal

2. Add validation to handlers:
   - execute: validate plan_path
   - status: validate run_id
   - All handlers: catch and format errors

3. Add error context:
   - Catch errors at layer boundaries
   - Add context (which layer, which operation)
   - Format user-friendly messages

4. Write tests:
   - Verify validation rejects invalid inputs
   - Verify error messages include context

**Acceptance Criteria**:

- [ ] Plan paths validated (must be under specs/)
- [ ] RunIds validated (6-char hex)
- [ ] Branch names validated (runId prefix)
- [ ] No shell injection vulnerabilities
- [ ] Error messages include context
- [ ] Tests pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Error handling per patterns.md. Security per architecture.md.

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:

```bash
pnpm test src/utils/validation.test.ts
pnpm check-types
```

---

### Task 5-3: Documentation & Examples

**Files**:
- README.md
- docs/slash-commands.md
- docs/examples/parallel-execution.md
- docs/examples/resume-from-failure.md

**Complexity**: M (3h)

**Dependencies**: None

**Description**:
Write user documentation: README with installation/usage, slash command templates for Codex CLI, example workflows (parallel execution, resume from failure). Reference constitution for architecture.

**Implementation Steps**:

1. Update README.md:
   - Project overview (MCP server for Spectacular in Codex)
   - Installation (npm install, MCP config)
   - Quick start (slash commands)
   - Architecture diagram (4 layers)
   - Link to constitution

2. Create docs/slash-commands.md:
   - Template slash commands for ~/.codex/prompts/
   - /spectacular:spec
   - /spectacular:plan
   - /spectacular:execute
   - /spectacular:status

3. Create example workflows:
   - docs/examples/parallel-execution.md: Full workflow from spec to execution
   - docs/examples/resume-from-failure.md: How resume logic works

4. No implementation code in this task (docs only)

**Acceptance Criteria**:

- [ ] README.md has installation instructions
- [ ] README.md has usage examples
- [ ] docs/slash-commands.md has template slash commands
- [ ] Example workflows documented
- [ ] Links to constitution included

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Documentation references constitution per CLAUDE.md.

**Quality Gates**:

```bash
pnpm biome check --write *.md docs/*.md
```

---

## Notes

**Testing Strategy:**

Per spec: "Testing deferred to separate implementation run (per user preference: implement then test)."

However, each task includes TDD (test-driven-development) as a mandatory pattern per constitution. Tests are written alongside implementation for quality gates.

**Constitution Compliance:**

Every task must follow:
- @docs/constitutions/current/architecture.md (4-layer architecture, module boundaries)
- @docs/constitutions/current/patterns.md (async job, pure utils, skills embedded, etc.)
- @docs/constitutions/current/tech-stack.md (TypeScript strict mode, dependencies)
- @docs/constitutions/current/schema-rules.md (git-based state, no database)

**Resume Logic:**

Git branches are the source of truth for task completion. If a task has a branch with commits, it is considered complete and skipped on resume.

**Parallelization:**

- Phase 1: 4 tasks in parallel (13h → 4h)
- Phase 2: 4 tasks in parallel (17h → 6h)
- Phase 3: 3 tasks in parallel (10h → 5h)
- Phase 4: 4 tasks in parallel (17h → 5h)
- Phase 5: 3 tasks in parallel (10h → 4h)

Total: 57h sequential → 41h parallel = 16h saved (28% faster)
